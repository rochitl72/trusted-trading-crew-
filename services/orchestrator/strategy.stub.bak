import os, random
import httpx
from typing import List, Dict, Any, Optional

# Agent service URLs (override via env if you deploy elsewhere)
ANALYST_URL    = os.getenv("ANALYST_URL",    "http://127.0.0.1:7010")
RESEARCHER_URL = os.getenv("RESEARCHER_URL", "http://127.0.0.1:7011")
MANAGER_URL    = os.getenv("MANAGER_URL",    "http://127.0.0.1:7012")

_DEFAULT_SYMBOLS = ["AAPL", "MSFT", "TSLA", "NVDA"]

def _fallback_ideas(symbols: Optional[List[str]]) -> List[Dict[str, Any]]:
    symbols = symbols or _DEFAULT_SYMBOLS
    out = []
    for s in symbols:
        score = round(random.uniform(-1, 1), 2)
        out.append({"symbol": s, "score": score, "rationale": "fallback"})
    # sort desc by score for nicer UX
    return sorted(out, key=lambda x: x["score"], reverse=True)

def _fallback_decide(symbol: str, side: Optional[str]) -> Dict[str, Any]:
    # naive: pick BUY if symbol's hash is even, else SELL; qty 5â€“10
    if side not in ("BUY","SELL"):
        side = "BUY" if (hash(symbol) % 2 == 0) else "SELL"
    qty = random.randint(2, 10)
    confidence = round(random.uniform(0.25, 0.9), 2)
    return {
        "symbol": symbol,
        "side": side,
        "qty": qty,
        "type": "market",
        "confidence": confidence,
        "source": "fallback-manager",
    }

def _safe_post(url: str, payload: dict, timeout: float = 6.0) -> Optional[dict]:
    try:
        with httpx.Client(timeout=timeout) as client:
            r = client.post(url, json=payload)
            r.raise_for_status()
            return r.json()
    except Exception:
        return None

def gather_ideas(symbols: Optional[List[str]] = None) -> List[Dict[str, Any]]:
    """
    Calls the Analyst service: POST {ANALYST_URL}/ideas  ->  {"ideas":[...]}
    Falls back to local scoring if the agent is down.
    """
    body = {"symbols": symbols} if symbols else {}
    resp = _safe_post(f"{ANALYST_URL}/ideas", body)
    if resp and isinstance(resp, dict) and "ideas" in resp:
        ideas = resp["ideas"]
        # Basic sanity: ensure required fields
        cleaned = []
        for it in ideas:
            if "symbol" in it and "score" in it:
                cleaned.append({
                    "symbol": it["symbol"],
                    "score": float(it["score"]),
                    "rationale": it.get("rationale", "analyst")
                })
        if cleaned:
            return cleaned
    # Fallback if agent unreachable or returned nothing
    return _fallback_ideas(symbols)

def decide_order(symbol: str, side: Optional[str] = None) -> Dict[str, Any]:
    """
    1) Ask Researcher for supporting evidence (optional)
       POST {RESEARCHER_URL}/support -> {"evidence": "..."} (any schema OK)
    2) Ask Manager to decide an order
       POST {MANAGER_URL}/decide -> {"intent": {...}}
    Falls back to a naive local manager if either service is down.
    """
    evidence = None
    resp_research = _safe_post(f"{RESEARCHER_URL}/support", {"symbol": symbol})
    if resp_research and isinstance(resp_research, dict):
        evidence = resp_research

    payload_mgr = {"symbol": symbol}
    if side: payload_mgr["side"] = side
    if evidence: payload_mgr["evidence"] = evidence

    resp_mgr = _safe_post(f"{MANAGER_URL}/decide", payload_mgr)
    if resp_mgr and isinstance(resp_mgr, dict) and "intent" in resp_mgr:
        intent = resp_mgr["intent"]
        # Safety defaults
        intent.setdefault("symbol", symbol)
        intent.setdefault("side", side or "BUY")
        intent.setdefault("qty", intent.get("qty", 5))
        intent.setdefault("type", intent.get("type", "market"))
        intent.setdefault("source", intent.get("source", "manager"))
        return intent

    # Fallback if manager unreachable
    return _fallback_decide(symbol, side)
